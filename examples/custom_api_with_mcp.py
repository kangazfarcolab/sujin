#!/usr/bin/env python
"""
Example of using a custom API with the MCP architecture.
"""

import os
import sys
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field

# Add the parent directory to the path so we can import the package
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.sujin.core.agent import Agent
from src.sujin.core.models import Message, AgentInput, AgentOutput
from src.sujin.tools.base import Tool
from src.sujin.clients.custom_api import CustomAPIClient
from src.sujin.plugins.mcp.base import MCPModel, MCPController, MCPControllerConfig, MCPPlugin
from src.sujin.plugins.base import PluginConfig


# Define a custom MCP model for processing API responses
class APIResponseModel(MCPModel):
    """Model for processing API responses."""
    content: str = Field(..., description="The content of the response")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


# Define a controller configuration
class ResponseFormatterConfig(MCPControllerConfig):
    """Configuration for the response formatter controller."""
    add_prefix: bool = Field(default=True, description="Whether to add a prefix to the response")
    prefix: str = Field(default="AI: ", description="Prefix to add to the response")
    add_suffix: bool = Field(default=True, description="Whether to add a suffix to the response")
    suffix: str = Field(default=" (Processed by MCP)", description="Suffix to add to the response")


# Define a controller for formatting responses
class ResponseFormatterController(MCPController[APIResponseModel, ResponseFormatterConfig]):
    """Controller for formatting API responses."""
    
    @classmethod
    def get_default_config(cls) -> ResponseFormatterConfig:
        """Get the default configuration for the controller."""
        return ResponseFormatterConfig()
        
    @property
    def name(self) -> str:
        """Get the name of the controller."""
        return "response_formatter"
        
    @property
    def description(self) -> str:
        """Get the description of the controller."""
        return "Formats API responses by adding prefixes and suffixes"
        
    def process(self, model: APIResponseModel, context: Dict[str, Any]) -> APIResponseModel:
        """
        Process the model by formatting the response.
        
        Args:
            model: The model to process
            context: Additional context for processing
            
        Returns:
            The processed model
        """
        # Add prefix if enabled
        if self.config.add_prefix:
            model.content = f"{self.config.prefix}{model.content}"
            
        # Add suffix if enabled
        if self.config.add_suffix:
            model.content = f"{model.content}{self.config.suffix}"
            
        # Add metadata
        model.metadata["processed_by"] = self.name
        model.metadata["formatter_config"] = self.config.dict()
        
        return model


# Define an MCP plugin for processing API responses
class APIResponsePlugin(MCPPlugin[APIResponseModel, ResponseFormatterConfig]):
    """Plugin for processing API responses."""
    
    def __init__(self, config: Optional[PluginConfig] = None):
        """
        Initialize a new API response plugin.
        
        Args:
            config: Configuration for the plugin
        """
        super().__init__(
            model_class=APIResponseModel,
            controllers=[
                ResponseFormatterController()
            ],
            config=config
        )
        
    @property
    def name(self) -> str:
        """Get the name of the plugin."""
        return "api_response_plugin"
        
    @property
    def description(self) -> str:
        """Get the description of the plugin."""
        return "Processes API responses using the MCP architecture"
        
    def pre_process(self, input_data: AgentInput) -> AgentInput:
        """
        Pre-process the input data before it's passed to the agent.
        
        Args:
            input_data: The input data to pre-process
            
        Returns:
            The pre-processed input data
        """
        # This plugin doesn't modify input data
        return input_data
        
    def post_process(self, output_data: AgentOutput) -> AgentOutput:
        """
        Post-process the output data after it's generated by the agent.
        
        Args:
            output_data: The output data to post-process
            
        Returns:
            The post-processed output data
        """
        # Create and process a model
        model = self.create_model(
            content=output_data.message.content,
            metadata=output_data.message.metadata or {}
        )
        
        processed_model = self.process_model(
            model,
            context={"output_data": output_data}
        )
        
        # Update the message with the processed content
        output_data.message.content = processed_model.content
        if output_data.message.metadata is None:
            output_data.message.metadata = {}
        output_data.message.metadata.update(processed_model.metadata)
        
        return output_data


# Define an agent that uses the custom API and MCP architecture
class CustomAPIWithMCPAgent(Agent):
    """An agent that uses a custom API with the MCP architecture."""
    
    def __init__(
        self, 
        name="CustomAPIWithMCPAgent",
        api_url="https://llm.chutes.ai/v1",
        api_key="cpk_f7f99ca38d4444d7b3003e6537d93d2b.961c728be2eb57348e16013b23a8453a.JE3meZydUdd9ZGv3sFTI8IGa1YtJ78Kv",
        model="RekaAI/reka-flash-3"
    ):
        super().__init__(name, "An agent that uses a custom API with the MCP architecture")
        
        # Create the API client
        self.client = CustomAPIClient(
            base_url=api_url,
            api_key=api_key,
            default_model=model
        )
        
        # Register the API response plugin
        self.register_plugin(APIResponsePlugin())
    
    def run(self, input_data: AgentInput) -> AgentOutput:
        """Process the input and return a response.
        
        Args:
            input_data: The input data to process
            
        Returns:
            The agent's output
        """
        # Get all messages
        messages = []
        for msg in input_data.messages:
            messages.append({
                "role": msg.role,
                "content": msg.content
            })
        
        # If no system message, add one
        if not any(msg["role"] == "system" for msg in messages):
            messages.insert(0, {
                "role": "system",
                "content": "You are a helpful assistant."
            })
        
        try:
            # Call the API
            response = self.client.chat_completion(
                messages=messages,
                temperature=0.7,
                max_tokens=150,
                timeout=30  # 30 second timeout
            )
            
            # Extract the response
            if response and "choices" in response and len(response["choices"]) > 0:
                choice = response["choices"][0]
                if "message" in choice and "content" in choice["message"]:
                    content = choice["message"]["content"]
                    
                    # Create metadata with usage information
                    metadata = {}
                    if "usage" in response:
                        metadata["usage"] = response["usage"]
                    
                    return AgentOutput(
                        message=Message(
                            role="assistant",
                            content=content,
                            metadata=metadata
                        )
                    )
            
            # Fallback response if API call fails or returns unexpected format
            return AgentOutput(
                message=Message(
                    role="assistant",
                    content="I'm sorry, I couldn't generate a response."
                )
            )
        except Exception as e:
            print(f"Error calling API: {e}")
            return AgentOutput(
                message=Message(
                    role="assistant",
                    content=f"I encountered an error: {str(e)}"
                )
            )


def main():
    # Create the agent
    agent = CustomAPIWithMCPAgent()
    
    print(f"Starting {agent.name}...")
    print("This agent uses a custom API with the MCP architecture.")
    print("The APIResponsePlugin adds 'AI: ' prefix and ' (Processed by MCP)' suffix to responses.")
    print("Type 'exit' to quit.")
    
    # Simple REPL
    while True:
        user_input = input("\n> ")
        if user_input.lower() == "exit":
            break
        
        # Process the input
        output = agent.process(user_input)
        print(f"\nResponse: {output.message.content}")
        
        # Print metadata if available
        if output.message.metadata:
            print("\nMetadata:")
            for key, value in output.message.metadata.items():
                if key == "usage":
                    print(f"  Tokens used: {value.get('total_tokens', 'N/A')} "
                          f"(Prompt: {value.get('prompt_tokens', 'N/A')}, "
                          f"Completion: {value.get('completion_tokens', 'N/A')})")
                elif key == "formatter_config":
                    print(f"  Formatter config: prefix='{value.get('prefix')}', suffix='{value.get('suffix')}'")
                else:
                    print(f"  {key}: {value}")


if __name__ == "__main__":
    main()
