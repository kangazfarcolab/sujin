#!/usr/bin/env python
"""
Simplified test of the custom API with MCP architecture.
"""

import os
import sys
import requests
import json
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field

# Add the parent directory to the path so we can import the package
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.sujin.core.models import Message, AgentInput, AgentOutput
from src.sujin.plugins.mcp.base import MCPModel, MCPController, MCPControllerConfig, MCPPlugin
from src.sujin.plugins.base import PluginConfig


# Define a simple MCP model
class APIResponseModel(MCPModel):
    """Model for processing API responses."""
    content: str = Field(..., description="The content of the response")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


# Define a simple controller configuration
class ResponseFormatterConfig(MCPControllerConfig):
    """Configuration for the response formatter controller."""
    prefix: str = Field(default="[MCP] ", description="Prefix to add to the response")
    suffix: str = Field(default=" [Processed]", description="Suffix to add to the response")


# Define a simple controller
class ResponseFormatterController(MCPController[APIResponseModel, ResponseFormatterConfig]):
    """Controller for formatting API responses."""

    @classmethod
    def get_default_config(cls) -> ResponseFormatterConfig:
        """Get the default configuration for the controller."""
        return ResponseFormatterConfig()

    @property
    def name(self) -> str:
        """Get the name of the controller."""
        return "response_formatter"

    @property
    def description(self) -> str:
        """Get the description of the controller."""
        return "Simple formatter that adds a prefix and suffix to responses"

    def process(self, model: APIResponseModel, context: Dict[str, Any]) -> APIResponseModel:
        """
        Process the model by formatting the response.

        Args:
            model: The model to process
            context: Additional context for processing

        Returns:
            The processed model
        """
        # Add prefix and suffix
        model.content = f"{self.config.prefix}{model.content}{self.config.suffix}"

        # Add metadata
        model.metadata["processed_by"] = self.name

        return model


# Define a simple MCP plugin
class APIResponsePlugin(MCPPlugin[APIResponseModel, ResponseFormatterConfig]):
    """Plugin for processing API responses."""

    def __init__(self, config: Optional[PluginConfig] = None):
        """
        Initialize a new API response plugin.

        Args:
            config: Configuration for the plugin
        """
        super().__init__(
            model_class=APIResponseModel,
            controllers=[
                ResponseFormatterController()
            ],
            config=config
        )

    @property
    def name(self) -> str:
        """Get the name of the plugin."""
        return "api_response_plugin"

    @property
    def description(self) -> str:
        """Get the description of the plugin."""
        return "Simple plugin for processing API responses"

    def pre_process(self, input_data: Any) -> Any:
        """
        Pre-process the input data before it's passed to the agent.

        Args:
            input_data: The input data to pre-process

        Returns:
            The pre-processed input data
        """
        # This plugin doesn't modify input data
        return input_data

    def post_process(self, output_data: AgentOutput) -> AgentOutput:
        """
        Post-process the output data after it's generated by the agent.

        Args:
            output_data: The output data to post-process

        Returns:
            The post-processed output data
        """
        # Create and process a model
        model = self.create_model(
            content=output_data.message.content,
            metadata=output_data.message.metadata or {}
        )

        processed_model = self.process_model(
            model,
            context={"output_data": output_data}
        )

        # Update the message with the processed content
        output_data.message.content = processed_model.content
        if output_data.message.metadata is None:
            output_data.message.metadata = {}
        output_data.message.metadata.update(processed_model.metadata)

        return output_data


def main():
    # API configuration
    api_url = "https://llm.chutes.ai/v1/chat/completions"
    api_key = "cpk_f7f99ca38d4444d7b3003e6537d93d2b.961c728be2eb57348e16013b23a8453a.JE3meZydUdd9ZGv3sFTI8IGa1YtJ78Kv"
    model = "RekaAI/reka-flash-3"

    # Create the MCP plugin
    plugin = APIResponsePlugin()

    # Headers
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }

    # Request data - extremely simple
    data = {
        "model": model,
        "messages": [
            {"role": "user", "content": "Hi"}
        ],
        "max_tokens": 10
    }

    print(f"Testing API with MCP")
    print(f"API URL: {api_url}")
    print(f"Model: {model}")
    print("\nSending request...")

    try:
        # Make the API request directly
        response = requests.post(
            api_url,
            headers=headers,
            json=data,
            timeout=10  # 10 second timeout
        )

        if response.status_code == 200:
            result = response.json()

            # Extract the response content
            if "choices" in result and len(result["choices"]) > 0:
                choice = result["choices"][0]
                if "message" in choice and "content" in choice["message"]:
                    content = choice["message"]["content"]

                    # Create metadata with usage information
                    metadata = {}
                    if "usage" in result:
                        metadata["usage"] = result["usage"]

                    # Create an AgentOutput
                    output = AgentOutput(
                        message=Message(
                            role="assistant",
                            content=content,
                            metadata=metadata
                        )
                    )

                    print("\nOriginal response:")
                    print("-" * 50)
                    print(output.message.content)
                    print("-" * 50)

                    # Process the output through the MCP plugin
                    processed_output = plugin.post_process(output)

                    print("\nProcessed response (after MCP):")
                    print("-" * 50)
                    print(processed_output.message.content)
                    print("-" * 50)

                    # Print metadata
                    if processed_output.message.metadata:
                        print("\nMetadata:")
                        for key, value in processed_output.message.metadata.items():
                            if key == "usage":
                                print(f"  Tokens used: {value.get('total_tokens', 'N/A')} "
                                    f"(Prompt: {value.get('prompt_tokens', 'N/A')}, "
                                    f"Completion: {value.get('completion_tokens', 'N/A')})")
                            else:
                                print(f"  {key}: {value}")

                    print("\nAPI with MCP test completed successfully!")
                else:
                    print("Error: Unexpected response format (no message content)")
                    print(f"Response: {json.dumps(result, indent=2)}")
            else:
                print("Error: Unexpected response format")
                print(f"Response: {json.dumps(result, indent=2)}")
        else:
            print(f"Error: Request failed with status code {response.status_code}")
            print(f"Response: {response.text}")

    except requests.exceptions.Timeout:
        print("Error: Request timed out after 10 seconds")
    except requests.exceptions.ConnectionError:
        print("Error: Connection error - could not connect to the API")
    except Exception as e:
        print(f"Error: {e}")

    print("\nTest completed.")


if __name__ == "__main__":
    main()
