#!/usr/bin/env python
"""
Combined test of the custom API with MCP architecture.
"""

import os
import sys
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field

# Add the parent directory to the path so we can import the package
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.sujin.core.models import Message, AgentInput, AgentOutput
from src.sujin.clients.custom_api import CustomAPIClient
from src.sujin.plugins.mcp.base import MCPModel, MCPController, MCPControllerConfig, MCPPlugin
from src.sujin.plugins.base import PluginConfig


# Define a simple MCP model
class APIResponseModel(MCPModel):
    """Model for processing API responses."""
    content: str = Field(..., description="The content of the response")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


# Define a simple controller configuration
class ResponseFormatterConfig(MCPControllerConfig):
    """Configuration for the response formatter controller."""
    prefix: str = Field(default="[MCP] ", description="Prefix to add to the response")
    suffix: str = Field(default=" [Processed]", description="Suffix to add to the response")


# Define a simple controller
class ResponseFormatterController(MCPController[APIResponseModel, ResponseFormatterConfig]):
    """Controller for formatting API responses."""
    
    @classmethod
    def get_default_config(cls) -> ResponseFormatterConfig:
        """Get the default configuration for the controller."""
        return ResponseFormatterConfig()
        
    @property
    def name(self) -> str:
        """Get the name of the controller."""
        return "response_formatter"
        
    @property
    def description(self) -> str:
        """Get the description of the controller."""
        return "Simple formatter that adds a prefix and suffix to responses"
        
    def process(self, model: APIResponseModel, context: Dict[str, Any]) -> APIResponseModel:
        """
        Process the model by formatting the response.
        
        Args:
            model: The model to process
            context: Additional context for processing
            
        Returns:
            The processed model
        """
        # Add prefix and suffix
        model.content = f"{self.config.prefix}{model.content}{self.config.suffix}"
        
        # Add metadata
        model.metadata["processed_by"] = self.name
        
        return model


# Define a simple MCP plugin
class APIResponsePlugin(MCPPlugin[APIResponseModel, ResponseFormatterConfig]):
    """Plugin for processing API responses."""
    
    def __init__(self, config: Optional[PluginConfig] = None):
        """
        Initialize a new API response plugin.
        
        Args:
            config: Configuration for the plugin
        """
        super().__init__(
            model_class=APIResponseModel,
            controllers=[
                ResponseFormatterController()
            ],
            config=config
        )
        
    @property
    def name(self) -> str:
        """Get the name of the plugin."""
        return "api_response_plugin"
        
    @property
    def description(self) -> str:
        """Get the description of the plugin."""
        return "Simple plugin for processing API responses"
        
    def pre_process(self, input_data: AgentInput) -> AgentInput:
        """
        Pre-process the input data before it's passed to the agent.
        
        Args:
            input_data: The input data to pre-process
            
        Returns:
            The pre-processed input data
        """
        # This plugin doesn't modify input data
        return input_data
        
    def post_process(self, output_data: AgentOutput) -> AgentOutput:
        """
        Post-process the output data after it's generated by the agent.
        
        Args:
            output_data: The output data to post-process
            
        Returns:
            The post-processed output data
        """
        # Create and process a model
        model = self.create_model(
            content=output_data.message.content,
            metadata=output_data.message.metadata or {}
        )
        
        processed_model = self.process_model(
            model,
            context={"output_data": output_data}
        )
        
        # Update the message with the processed content
        output_data.message.content = processed_model.content
        if output_data.message.metadata is None:
            output_data.message.metadata = {}
        output_data.message.metadata.update(processed_model.metadata)
        
        return output_data


def main():
    # API configuration
    api_url = "https://llm.chutes.ai/v1"
    api_key = "cpk_f7f99ca38d4444d7b3003e6537d93d2b.961c728be2eb57348e16013b23a8453a.JE3meZydUdd9ZGv3sFTI8IGa1YtJ78Kv"
    model = "RekaAI/reka-flash-3"
    
    # Create the API client
    client = CustomAPIClient(
        base_url=api_url,
        api_key=api_key,
        default_model=model
    )
    
    # Create the MCP plugin
    plugin = APIResponsePlugin()
    
    # Predefined prompt - using a very simple prompt to get a quick response
    prompt = "Say hello"
    
    print(f"API URL: {api_url}")
    print(f"Model: {model}")
    print(f"Prompt: '{prompt}'")
    print("Sending request...")
    
    try:
        # Call the API with a short timeout
        response = client.chat_completion(
            messages=[
                {"role": "system", "content": "You are a helpful assistant. Keep responses very brief."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=20,  # Very small to get a quick response
            timeout=10  # 10 second timeout
        )
        
        # Extract the response
        if response and "choices" in response and len(response["choices"]) > 0:
            choice = response["choices"][0]
            if "message" in choice and "content" in choice["message"]:
                content = choice["message"]["content"]
                
                # Create metadata with usage information
                metadata = {}
                if "usage" in response:
                    metadata["usage"] = response["usage"]
                
                # Create an AgentOutput
                output = AgentOutput(
                    message=Message(
                        role="assistant",
                        content=content,
                        metadata=metadata
                    )
                )
                
                print("\nOriginal response:")
                print("-" * 50)
                print(output.message.content)
                print("-" * 50)
                
                # Process the output through the MCP plugin
                processed_output = plugin.post_process(output)
                
                print("\nProcessed response (after MCP):")
                print("-" * 50)
                print(processed_output.message.content)
                print("-" * 50)
                
                # Print metadata
                if processed_output.message.metadata:
                    print("\nMetadata:")
                    for key, value in processed_output.message.metadata.items():
                        if key == "usage":
                            print(f"  Tokens used: {value.get('total_tokens', 'N/A')} "
                                f"(Prompt: {value.get('prompt_tokens', 'N/A')}, "
                                f"Completion: {value.get('completion_tokens', 'N/A')})")
                        else:
                            print(f"  {key}: {value}")
                
                print("\nCombined API and MCP test completed successfully!")
            else:
                print("Error: Unexpected response format (no message content)")
                print(f"Response: {response}")
        else:
            print("Error: Unexpected response format")
            print(f"Response: {response}")
    except Exception as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    main()
