#!/usr/bin/env python
"""
Simple test of MCP architecture with a custom API.
This script makes a single API call with a predefined prompt,
processes the response through the MCP architecture, and displays the results.
"""

import os
import sys
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field

# Add the parent directory to the path so we can import the package
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.sujin.core.models import Message, AgentInput, AgentOutput
from src.sujin.clients.custom_api import CustomAPIClient
from src.sujin.plugins.mcp.base import MCPModel, MCPController, MCPControllerConfig, MCPPlugin
from src.sujin.plugins.base import PluginConfig


# Define a simple MCP model
class SimpleResponseModel(MCPModel):
    """Model for processing API responses."""
    content: str = Field(..., description="The content of the response")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")


# Define a simple controller configuration
class SimpleFormatterConfig(MCPControllerConfig):
    """Configuration for the simple formatter controller."""
    prefix: str = Field(default="[MCP] ", description="Prefix to add to the response")
    suffix: str = Field(default=" [Processed]", description="Suffix to add to the response")


# Define a simple controller
class SimpleFormatterController(MCPController[SimpleResponseModel, SimpleFormatterConfig]):
    """Controller for formatting API responses."""

    @classmethod
    def get_default_config(cls) -> SimpleFormatterConfig:
        """Get the default configuration for the controller."""
        return SimpleFormatterConfig()

    @property
    def name(self) -> str:
        """Get the name of the controller."""
        return "simple_formatter"

    @property
    def description(self) -> str:
        """Get the description of the controller."""
        return "Simple formatter that adds a prefix and suffix to responses"

    def process(self, model: SimpleResponseModel, context: Dict[str, Any]) -> SimpleResponseModel:
        """
        Process the model by formatting the response.

        Args:
            model: The model to process
            context: Additional context for processing

        Returns:
            The processed model
        """
        # Add prefix and suffix
        model.content = f"{self.config.prefix}{model.content}{self.config.suffix}"

        # Add metadata
        model.metadata["processed_by"] = self.name

        return model


# Define a simple MCP plugin
class SimpleResponsePlugin(MCPPlugin[SimpleResponseModel, SimpleFormatterConfig]):
    """Plugin for processing API responses."""

    def __init__(self, config: Optional[PluginConfig] = None):
        """
        Initialize a new simple response plugin.

        Args:
            config: Configuration for the plugin
        """
        super().__init__(
            model_class=SimpleResponseModel,
            controllers=[
                SimpleFormatterController()
            ],
            config=config
        )

    @property
    def name(self) -> str:
        """Get the name of the plugin."""
        return "simple_response_plugin"

    @property
    def description(self) -> str:
        """Get the description of the plugin."""
        return "Simple plugin for processing API responses"

    def pre_process(self, input_data: AgentInput) -> AgentInput:
        """
        Pre-process the input data before it's passed to the agent.

        Args:
            input_data: The input data to pre-process

        Returns:
            The pre-processed input data
        """
        # This plugin doesn't modify input data
        return input_data

    def post_process(self, output_data: AgentOutput) -> AgentOutput:
        """
        Post-process the output data after it's generated by the agent.

        Args:
            output_data: The output data to post-process

        Returns:
            The post-processed output data
        """
        # Create and process a model
        model = self.create_model(
            content=output_data.message.content,
            metadata=output_data.message.metadata or {}
        )

        processed_model = self.process_model(
            model,
            context={"output_data": output_data}
        )

        # Update the message with the processed content
        output_data.message.content = processed_model.content
        if output_data.message.metadata is None:
            output_data.message.metadata = {}
        output_data.message.metadata.update(processed_model.metadata)

        return output_data


def main():
    # API configuration
    api_url = "https://llm.chutes.ai/v1"
    api_key = "cpk_f7f99ca38d4444d7b3003e6537d93d2b.961c728be2eb57348e16013b23a8453a.JE3meZydUdd9ZGv3sFTI8IGa1YtJ78Kv"
    model = "RekaAI/reka-flash-3"

    # Create the API client
    client = CustomAPIClient(
        base_url=api_url,
        api_key=api_key,
        default_model=model
    )

    # Create the MCP plugin
    plugin = SimpleResponsePlugin()

    # Predefined prompt
    prompt = "What is the capital of France?"

    print(f"API URL: {api_url}")
    print(f"Model: {model}")
    print(f"Prompt: '{prompt}'")
    print("Sending request...")

    try:
        # Call the API
        response = client.chat_completion(
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=150
        )

        # Extract the response
        if response and "choices" in response and len(response["choices"]) > 0:
            choice = response["choices"][0]
            if "message" in choice and "content" in choice["message"]:
                content = choice["message"]["content"]

                # Create metadata with usage information
                metadata = {}
                if "usage" in response:
                    metadata["usage"] = response["usage"]

                # Create an AgentOutput
                output = AgentOutput(
                    message=Message(
                        role="assistant",
                        content=content,
                        metadata=metadata
                    )
                )

                print("\nOriginal response:")
                print("-" * 50)
                print(output.message.content)
                print("-" * 50)

                # Process the output through the MCP plugin
                processed_output = plugin.post_process(output)

                print("\nProcessed response (after MCP):")
                print("-" * 50)
                print(processed_output.message.content)
                print("-" * 50)

                # Print metadata
                if processed_output.message.metadata:
                    print("\nMetadata:")
                    for key, value in processed_output.message.metadata.items():
                        if key == "usage":
                            print(f"  Tokens used: {value.get('total_tokens', 'N/A')} "
                                f"(Prompt: {value.get('prompt_tokens', 'N/A')}, "
                                f"Completion: {value.get('completion_tokens', 'N/A')})")
                        else:
                            print(f"  {key}: {value}")

                print("\nMCP test completed successfully!")
            else:
                print("Error: Unexpected response format (no message content)")
                print(f"Response: {response}")
        else:
            print("Error: Unexpected response format")
            print(f"Response: {response}")
    except Exception as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    main()
